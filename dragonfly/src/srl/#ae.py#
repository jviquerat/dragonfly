import numpy as np
import tensorflow as tf

from tensorflow.keras import layers, losses
from tensorflow.keras.datasets import fashion_mnist
from tensorflow.keras.models import Model

# Custom imports
from dragonfly.src.srl.base import *



class Autoencoder(Model):
    def __init__(self, latent_dim, shape):
        super(Autoencoder, self).__init__()
        self.latent_dim = latent_dim
        self.shape = shape
        self.encoder = tf.keras.Sequential([
            layers.Flatten(),
            layers.Dense(latent_dim, activation='relu'),
        ])
        self.decoder = tf.keras.Sequential([
            layers.Dense(tf.math.reduce_prod(shape), activation='sigmoid'),
            layers.Reshape(shape)
        ])
        
    def call(self, x):
        encoded = self.encoder(x)
        decoded = self.decoder(encoded)
        return decoded


class ae():
    def __init__(self, dim, new_dim, freq, size):

        # Initialize from arguments
        self.obs_dim = dim
        self.buff_size = size
        self.reduced_dim = new_dim
        self.freq = freq

        # Initialize counter
        self.counter = 1

        # Create buffers
        self.names = ["obs"]
        self.sizes = [self.obs_dim]
        self.gbuff = gbuff(self.buff_size, self.names, self.sizes)

        # Initialize Autoencoder
        self.autoencoder = Autoencoder(new_dim, (dim,1))
        self.autoencoder.compile(optimizer='adam',
                                 loss=losses.MeanSquaredError())

    def update(self):

        # Get data
        obs = self.gbuff.get_buffers({"obs"},self.counter)["obs"]
        n = obs.shape[0]
        n_test = int(n/7)
        x_train = obs[:n-n_test,:]
        x_test = obs[n-n_test:,:]

        # Train autoencoder
        self.autoencoder.fit(x_train, x_train,
                             epochs=1,
                             shuffle=True,
                             validation_data=(x_test, x_test))


    def process(self, obs):

        # Before the update time
        if (self.counter < self.freq) :
            return obs[:,:self.reduced_dim]

        # Check if it's the update time
        if ((self.counter % self.freq)==0) :
            self.update()

        # Call the autoencoder
        encoded_obs = self.autoencoder.encoder(obs).numpy()
        return encoded_obs

    
